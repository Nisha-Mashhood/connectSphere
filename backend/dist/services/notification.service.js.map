{"version":3,"file":"notification.service.js","sourceRoot":"","sources":["../../src/services/notification.service.ts"],"names":[],"mappings":"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","sourcesContent":["import * as notificationRepository from \"../repositories/notification.repositry.js\";\r\nimport webPush from \"../utils/webPushUtil.js\";\r\n\r\nexport interface PushSubscription {\r\n  endpoint: string;\r\n  keys: {\r\n    auth: string;\r\n    p256dh: string;\r\n  };\r\n}\r\n\r\ninterface ExtendedPushSubscription extends PushSubscription {\r\n  userId?: string;\r\n}\r\n\r\n//Store subscription details in DB\r\nexport const storeSubscription = async (currentUserId: string, taskId: string, subscription: PushSubscription) => {\r\n  // Validate subscription object before storing\r\n  if (!subscription || !subscription.endpoint || !subscription.keys) {\r\n    throw new Error(\"Invalid subscription object\");\r\n  }\r\n  return notificationRepository.saveSubscription(taskId, subscription, { userId: currentUserId });\r\n};\r\n\r\n// Send push notifications for a specific task and user\r\nexport const sendPushNotification = async (\r\n  taskId: string, \r\n  message?: string, \r\n  specificUserId?: string\r\n): Promise<void> => {\r\n  try {\r\n    // Get task details\r\n    const task = await notificationRepository.getTasksForNotification(taskId);\r\n\r\n    if (!task) {\r\n      console.log(\"No notifications found for this Task\");\r\n      return;\r\n    }\r\n\r\n    let recipients: string[] = [];\r\n\r\n    // If a specific user ID is provided, use only that user\r\n    if (specificUserId) {\r\n      recipients = [specificUserId];\r\n    } else {\r\n      // Existing logic for determining recipients based on context\r\n      if (task.contextType === \"profile\") {\r\n        recipients.push(task.createdBy.toString());\r\n      } else if (task.contextType === \"group\") {\r\n        const groupMembers = await notificationRepository.getGroupMembers(task.contextId.toString());\r\n        recipients = groupMembers.map(member => member.toString());\r\n      } else if (task.contextType === \"collaboration\") {\r\n        const collaborationIds = await notificationRepository.getMentorIdAndUserId(task.contextId.toString());\r\n        \r\n        if (collaborationIds) {\r\n          recipients = [collaborationIds.userId, collaborationIds.mentorUserId]\r\n            .filter((id): id is string => id !== null);\r\n        }\r\n      }\r\n    }\r\n\r\n    for (const userId of recipients) {\r\n      // Get the subscription for the specific userID\r\n      const taskWithSubscription = await notificationRepository.getUserSubscription(userId);\r\n      if (!taskWithSubscription?.notificationSubscription) continue;\r\n\r\n      const subscription = taskWithSubscription.notificationSubscription as ExtendedPushSubscription;\r\n\r\n      const payload = JSON.stringify({\r\n        title: `Reminder: ${task.name}`,\r\n        body: message || `Remember to complete \"${task.name}\"`,\r\n        icon: task.image || \"/default-icon.png\",\r\n        taskId: task._id\r\n      });\r\n\r\n      try {\r\n        await webPush.sendNotification(subscription, payload);\r\n        console.log(`Notification sent for Task: ${task._id} to User: ${userId}`);\r\n      } catch (error) {\r\n        console.error(`Error sending notification for task ${task._id} to user ${userId}:`, error);\r\n      }\r\n    }\r\n\r\n  } catch (error) {\r\n    console.error(\"Error in sendPushNotification:\", error);\r\n    throw error;\r\n  }\r\n};\r\n"]}