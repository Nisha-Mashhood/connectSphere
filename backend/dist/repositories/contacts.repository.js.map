{"version":3,"file":"contacts.repository.js","sourceRoot":"","sources":["../../src/repositories/contacts.repository.ts"],"names":[],"mappings":"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","sourcesContent":["import Contact, { IContact } from \"../models/contacts.model.js\";\r\nimport mongoose from \"mongoose\";\r\n\r\n// Utility to convert string to ObjectId\r\nconst toObjectId = (id: string) => new mongoose.Types.ObjectId(id);\r\n\r\n// Create a single Contact document\r\nexport const createContact = async (contactData: Partial<IContact>): Promise<IContact> => {\r\n  try {\r\n    const contact = new Contact({\r\n      ...contactData,\r\n      userId: contactData.userId && typeof contactData.userId === \"string\" ? toObjectId(contactData.userId) : contactData.userId,\r\n      targetUserId: contactData.targetUserId && typeof contactData.targetUserId === \"string\" ? toObjectId(contactData.targetUserId) : contactData.targetUserId,\r\n      collaborationId: contactData.collaborationId && typeof contactData.collaborationId === \"string\" ? toObjectId(contactData.collaborationId) : contactData.collaborationId,\r\n      userConnectionId: contactData.userConnectionId && typeof contactData.userConnectionId === \"string\" ? toObjectId(contactData.userConnectionId) : contactData.userConnectionId,\r\n      groupId: contactData.groupId && typeof contactData.groupId === \"string\" ? toObjectId(contactData.groupId) : contactData.groupId,\r\n    });\r\n    return await contact.save();\r\n  } catch (error: any) {\r\n    throw new Error(`Error creating contact: ${error.message}`);\r\n  }\r\n};\r\n\r\n// Find a contact by its ID\r\nexport const findContactById = async (contactId: string): Promise<IContact | null> => {\r\n  try {\r\n    return await Contact.findById(toObjectId(contactId)).exec();\r\n  } catch (error: any) {\r\n    throw new Error(`Error finding contact by ID: ${error.message}`);\r\n  }\r\n};\r\n\r\n// Find a contact by userId and targetUserId (for user-user or user-mentor chats)\r\nexport const findContactByUsers = async (userId: string, targetUserId: string): Promise<IContact | null> => {\r\n  try {\r\n    return await Contact.findOne({\r\n      $or: [\r\n        { userId: toObjectId(userId), targetUserId: toObjectId(targetUserId) },\r\n        { userId: toObjectId(targetUserId), targetUserId: toObjectId(userId) }, // Bidirectional check\r\n      ],\r\n      type: { $in: [\"user-user\", \"user-mentor\"] }, // Ensure type matches\r\n    }).exec();\r\n  } catch (error: any) {\r\n    throw new Error(`Error finding contact by user IDs: ${error.message}`);\r\n  }\r\n};\r\n\r\nexport interface PopulatedContact {\r\n  _id: string | mongoose.Types.ObjectId;\r\n  contactId: string;\r\n  userId: { _id: string; name?: string; profilePic?: string };\r\n  targetUserId?: { _id: string; name?: string; profilePic?: string };\r\n  collaborationId?: {\r\n    _id: string;\r\n    mentorId: { userId: { _id: string; name?: string; profilePic?: string } };\r\n    userId: { _id: string; name?: string; profilePic?: string };\r\n  };\r\n  userConnectionId?: {\r\n    _id: string;\r\n    requester: { _id: string; name?: string; profilePic?: string };\r\n    recipient: { _id: string; name?: string; profilePic?: string };\r\n  };\r\n  groupId?: { _id: string; name?: string; profilePic?: string };\r\n  type: \"user-mentor\" | \"user-user\" | \"group\";\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n}\r\n\r\n\r\nexport const findContactsByUserId = async (userId: string): Promise<PopulatedContact[]> => {\r\n  try {\r\n    return await Contact.find({\r\n      $or: [\r\n        { userId: toObjectId(userId) },\r\n        { targetUserId: toObjectId(userId) },\r\n      ],\r\n    })\r\n      .populate({\r\n        path: \"userId\",\r\n        select: \"name profilePic userId\",\r\n        model: \"User\",\r\n      })\r\n      .populate({\r\n        path: \"targetUserId\",\r\n        select: \"name profilePic userId\",\r\n        model: \"User\",\r\n      })\r\n      .populate({\r\n        path: \"collaborationId\",\r\n        select: \"mentorId userId\",\r\n        model: \"Collaboration\",\r\n        populate: [\r\n          { path: \"mentorId\", select: \"userId\", populate: { path: \"userId\", select: \"name profilePic\" } },\r\n          { path: \"userId\", select: \"name profilePic\" },\r\n        ],\r\n      })\r\n      .populate({\r\n        path: \"userConnectionId\",\r\n        select: \"requester recipient\",\r\n        model: \"UserConnection\",\r\n        populate: [\r\n          { path: \"requester\", select: \"name profilePic\" },\r\n          { path: \"recipient\", select: \"name profilePic\" },\r\n        ],\r\n      })\r\n      .populate({\r\n        path: \"groupId\",\r\n        select: \"name profilePic groupId\",\r\n        model: \"Group\",\r\n      })\r\n      .lean()\r\n      .exec() as unknown as PopulatedContact[]; \r\n  } catch (error: any) {\r\n    throw new Error(`Error finding contacts by user ID: ${error.message}`);\r\n  }\r\n};"]}